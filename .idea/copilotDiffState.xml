<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/python_code/channel/mimo_channels/sed_channel.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/python_code/channel/mimo_channels/sed_channel.py" />
              <option name="originalContent" value="import numpy as np&#10;from sympy import false&#10;&#10;from python_code import conf&#10;from python_code.utils.constants import (NUM_SYMB_PER_SLOT, FFT_size, FIRST_CP,CP, NUM_SAMPLES_PER_SLOT)&#10;&#10;import matplotlib.pyplot as plt&#10;import tensorflow as tf&#10;from typing import Tuple&#10;&#10;from python_code.analog.iqmm_model import apply_iq_mismatch&#10;&#10;&#10;&#10;H_COEF = 0.8&#10;&#10;from python_code.channel.sionna.TLD_channel import TDLChannel&#10;&#10;&#10;class SEDChannel:&#10;    @staticmethod&#10;    def calculate_channel(n_ant: int, n_users: int, num_res: int) -&gt; np.ndarray:&#10;        H_real = SEDChannel.mapping_matrix(n_users, n_ant)&#10;        H_complex = np.zeros((H_real.shape[0], H_real.shape[1], num_res), dtype=complex)&#10;        for re_index in range(num_res):&#10;            H_complex[:,:,re_index] = H_real&#10;        return H_complex&#10;&#10;&#10;    @staticmethod&#10;    def hadamard_matrix(n):&#10;        &quot;&quot;&quot;Generate Hadamard matrix of order n (must be power of 2).&quot;&quot;&quot;&#10;        if n == 1:&#10;            return np.array([[1]])&#10;        H = SEDChannel.hadamard_matrix(n // 2)&#10;        return np.block([[H, H], [H, -H]])&#10;&#10;    @staticmethod&#10;    def mapping_matrix(n_layers, n_rx):&#10;        &quot;&quot;&quot;Generate mapping matrix using Hadamard construction.&quot;&quot;&quot;&#10;        # Find nearest power of 2 &gt;= n_rx&#10;        N = 1&#10;        while N &lt; n_rx:&#10;            N *= 2&#10;        H = SEDChannel.hadamard_matrix(N)&#10;&#10;        # Normalize&#10;        H = H / np.sqrt(N)&#10;&#10;        # Take first n_rx rows and first n_layers columns&#10;        return H[:n_rx, :n_layers]&#10;&#10;&#10;    @staticmethod&#10;    def _add_fading(H: np.ndarray, n_ant: int, frame_ind: int) -&gt; np.ndarray:&#10;        degs_array = np.array([51, 39, 33, 21])&#10;        fade_mat = H_COEF + (1 - H_COEF) * np.cos(2 * np.pi * frame_ind / degs_array)&#10;        fade_mat = np.tile(fade_mat.reshape(1, -1), [n_ant, 1])&#10;        return H * fade_mat&#10;&#10;    @staticmethod&#10;    def apply_td_and_impairments(y_in, td_in_rx, cfo, clip_percentage_in_tx, num_res, n_users, tdl_channel: bool, external_chan: tf.Tensor, iqmm_gain, iqmm_phase, seed, run_tdcnn) -&gt; Tuple[np.ndarray, tf.Tensor]:&#10;&#10;        if td_in_rx:&#10;            if not(tdl_channel):&#10;                if y_in.ndim == 4:&#10;                    NUM_SLOTS = int(y_in.shape[2] / NUM_SYMB_PER_SLOT)&#10;                    NUM_SAMPLES_TOTAL = int(NUM_SLOTS * NUM_SAMPLES_PER_SLOT)&#10;                    n_users_int = n_users&#10;                    y = y_in&#10;                else:&#10;                    NUM_SLOTS = int(y_in.shape[1] / NUM_SYMB_PER_SLOT)&#10;                    NUM_SAMPLES_TOTAL = int(NUM_SLOTS * NUM_SAMPLES_PER_SLOT)&#10;                    n_users_int = 1&#10;                    y = np.expand_dims(y_in, axis=0)&#10;                n_input_rx_int = y.shape[1]&#10;                n_users_out_int = n_users_int&#10;            else:&#10;                NUM_SLOTS = int(y_in.shape[1] / NUM_SYMB_PER_SLOT)&#10;                NUM_SAMPLES_TOTAL = int(NUM_SLOTS * NUM_SAMPLES_PER_SLOT)&#10;                n_users_int = y_in.shape[0]&#10;                y = np.expand_dims(y_in, axis=1)&#10;                n_input_rx_int = 1&#10;                n_users_out_int = 1&#10;        else:&#10;            NUM_SLOTS = int(y_in.shape[1] / NUM_SYMB_PER_SLOT)&#10;            NUM_SAMPLES_TOTAL = int(NUM_SLOTS * NUM_SAMPLES_PER_SLOT)&#10;            n_users_int = n_users&#10;            n_input_rx_int = 1;&#10;            n_users_out_int = n_users&#10;            y = np.expand_dims(y_in, axis=1)&#10;&#10;        st_full = np.zeros((n_users_int, n_input_rx_int, NUM_SAMPLES_TOTAL), dtype=complex)&#10;&#10;        # OFDM modulation:&#10;        for user in range(n_users_int):&#10;            for rx in range(n_input_rx_int):&#10;                st_one_antenna = np.array([])&#10;                for slot_num in range(NUM_SLOTS):&#10;                    cp_length = FIRST_CP&#10;                    for ofdm_symbol in range(NUM_SYMB_PER_SLOT):&#10;                        cur_index = slot_num * NUM_SYMB_PER_SLOT + ofdm_symbol&#10;                        s_t = np.fft.ifft(y[user, rx, cur_index, :], n=FFT_size)&#10;                        s_t_with_cp = np.concatenate((s_t[-cp_length:], s_t))&#10;                        st_one_antenna = np.concatenate((st_one_antenna, s_t_with_cp))&#10;                        cp_length = CP&#10;                st_full[user,rx, :] = st_one_antenna&#10;&#10;        if (cfo != 0):&#10;            n = np.arange(NUM_SAMPLES_PER_SLOT)&#10;            cfo_phase = 2 * np.pi * cfo * n / FFT_size  # CFO phase shift&#10;            cfo_phase = np.tile(cfo_phase,NUM_SLOTS)&#10;            st_full = st_full * np.exp(1j * cfo_phase)&#10;&#10;        # Save a copy of the time-domain signal before clipping when TD-CNN input is requested&#10;        if run_tdcnn:&#10;            st_full_before = st_full.copy()&#10;        else:&#10;            st_full_before = None&#10;&#10;        if clip_percentage_in_tx&lt;100:&#10;            rms_value = np.mean(np.sqrt(np.mean(np.abs(st_full) ** 2, axis=2)))  # Compute RMS of the signal&#10;            clip_level_12dB = rms_value * (10 ** (12 / 20))  # 12 dB above RMS&#10;            clip_level = (clip_percentage_in_tx / 100) * clip_level_12dB  # Scale by percentage&#10;&#10;            magnitude = np.abs(st_full)  # Compute magnitude&#10;            phase = np.angle(st_full)  # Compute phase&#10;&#10;            # Apply clipping to magnitude&#10;            magnitude_clipped = np.minimum(magnitude, clip_level)&#10;&#10;            # Reconstruct clipped signal with original phase&#10;            st_full = magnitude_clipped * np.exp(1j * phase)&#10;            # new_rms_value = np.mean(np.sqrt(np.mean(np.abs(st_full) ** 2, axis=2)))  # Compute RMS of the signal&#10;            # st_full = st_full*rms_value/new_rms_value&#10;&#10;&#10;        # from scipy.io import savemat&#10;        # savemat('C:\\Projects\\Scratchpad\\temp_mat_files\\clip_debug.mat', {'st_full_before': st_full_before, 'st_full_after': st_full})&#10;&#10;&#10;        if iqmm_gain!=0 or iqmm_phase!=0:&#10;            st_full = apply_iq_mismatch(st_full, iqmm_gain, iqmm_phase)&#10;&#10;        if tdl_channel and td_in_rx:&#10;            st_out, chan_out = TDLChannel.conv_cir(st_full,1,0, NUM_SLOTS, external_chan, seed)&#10;            st_full = st_out&#10;        else:&#10;            chan_out = tf.zeros([0], dtype=tf.float32)&#10;&#10;        y_out_pre = np.zeros((n_users_out_int,st_full.shape[1],y.shape[2],y.shape[3]), dtype=np.complex64)&#10;        # --- Added for s_t_no_cp collection ---&#10;        # --- Allocate s_t_no_cp_matrix and s_t_no_cp_matrix_before with an explicit user dimension&#10;        # so the shape becomes (n_users_out_int, NUM_SLOTS, 2*n_rx, FFT_size, NUM_SYMB_PER_SLOT).&#10;        if run_tdcnn:&#10;            s_t_no_cp_matrix = np.zeros((n_users_out_int, NUM_SLOTS, 2 * st_full.shape[1], FFT_size, NUM_SYMB_PER_SLOT), dtype=np.float32)&#10;            # Keep a copy of the same structure for the pre-clipping samples&#10;            s_t_no_cp_matrix_before = np.zeros_like(s_t_no_cp_matrix)&#10;        else:&#10;            s_t_no_cp_matrix = None&#10;            s_t_no_cp_matrix_before = None&#10;        # --------------------------------------------------------------------------------------&#10;        for user in range(n_users_out_int):&#10;            for rx in range(st_full.shape[1]):&#10;                pointer = 0&#10;                index = 0&#10;                for slot_num in range(NUM_SLOTS):&#10;                    cp_length = FIRST_CP&#10;                    for ofdm_symbol in range(NUM_SYMB_PER_SLOT):&#10;                        s_t_no_cp = st_full[user, rx, pointer + cp_length:pointer + cp_length + FFT_size]&#10;                        S_no_cp = np.fft.fft(s_t_no_cp, n=FFT_size)&#10;                        y_out_pre[user, rx, index, :] = S_no_cp[:num_res]&#10;                        # --- Store real and imag in the matrix ---&#10;                        if run_tdcnn:&#10;                            # post-clipping samples: store under the [user, slot_num, ...] index&#10;                            s_t_no_cp_matrix[user, slot_num, 2*rx, :, ofdm_symbol] = np.real(s_t_no_cp)&#10;                            s_t_no_cp_matrix[user, slot_num, 2*rx+1, :, ofdm_symbol] = np.imag(s_t_no_cp)&#10;&#10;                            # pre-clipping samples (if available)&#10;                            if st_full_before is not None:&#10;                                s_t_no_cp_before = st_full_before[user, rx, pointer + cp_length:pointer + cp_length + FFT_size]&#10;                                s_t_no_cp_matrix_before[user, slot_num, 2*rx, :, ofdm_symbol] = np.real(s_t_no_cp_before)&#10;                                s_t_no_cp_matrix_before[user, slot_num, 2*rx+1, :, ofdm_symbol] = np.imag(s_t_no_cp_before)&#10;                        # ----------------------------------------&#10;                        pointer += (cp_length + FFT_size)&#10;                        cp_length = CP&#10;                        index += 1&#10;        # s_t_no_cp_matrix is now organized as (n_users_out_int, NUM_SLOTS, 2*n_rx, FFT_size, NUM_SYMB_PER_SLOT)&#10;        # where the first axis indexes the user and the second axis indexes the slot.&#10;&#10;        if td_in_rx:&#10;            if y_in.ndim == 4: # Multiple users&#10;                y_out = y_out_pre&#10;            else:&#10;                y_out = np.squeeze(y_out_pre, axis=0)&#10;        else:&#10;            y_out = np.squeeze(y_out_pre, axis=1)&#10;&#10;&#10;&#10;        # -----------------------------------------------------------------------------------------------&#10;        show_impair_tx = False&#10;        if show_impair_tx:&#10;            fig, axs = plt.subplots(4, 1, figsize=(8, 10))&#10;&#10;            # --- Real part ---&#10;            axs[0].stem(np.real(y_in[0, 0, :]), linefmt='b-', markerfmt='bo', basefmt=&quot; &quot;, label='Before')&#10;            axs[0].stem(np.real(y_out[0, 0, :]), linefmt='r--', markerfmt='ro', basefmt=&quot; &quot;, label='After')&#10;            axs[0].set_ylabel('I')&#10;            axs[0].grid(True)&#10;            axs[0].legend()&#10;&#10;            # --- Imag part ---&#10;            axs[1].stem(np.imag(y_in[0, 0, :]), linefmt='b-', markerfmt='bo', basefmt=&quot; &quot;, label='Before')&#10;            axs[1].stem(np.imag(y_out[0, 0, :]), linefmt='r--', markerfmt='ro', basefmt=&quot; &quot;, label='After')&#10;            axs[1].set_ylabel('Q')&#10;            axs[1].grid(True)&#10;            axs[1].legend()&#10;&#10;            # --- Abs ---&#10;            axs[2].stem(np.abs(y_in[0, 0, :]), linefmt='b-', markerfmt='bo', basefmt=&quot; &quot;, label='Before')&#10;            axs[2].stem(np.abs(y_out[0, 0, :]), linefmt='r--', markerfmt='ro', basefmt=&quot; &quot;, label='After')&#10;            axs[2].set_ylabel('Abs')&#10;            axs[2].grid(True)&#10;            axs[2].legend()&#10;&#10;            # --- Constellation diagram ---&#10;            axs[3].scatter(np.real(y_out.flatten()), np.imag(y_out.flatten()), color='r', alpha=0.5,&#10;                           label='After')&#10;            axs[3].scatter(np.real(y_in.flatten()), np.imag(y_in.flatten()), color='b', alpha=0.5,&#10;                           label='Before')&#10;            axs[3].set_xlabel('I')&#10;            axs[3].set_ylabel('Q')&#10;            axs[3].grid(True)&#10;            axs[3].axis('equal')&#10;            axs[3].legend()&#10;&#10;            # --- Global title ---&#10;            # fig.suptitle('Impairment effect with clipping = ' + str(clip_percentage_in_tx) + '%', fontsize=14)&#10;            fig.suptitle('Impairment effect with IQMM gain = ' + str(conf.iqmm_gain) + 'dB, phase=' + str(conf.iqmm_phase) + '°', fontsize=14)&#10;&#10;            plt.tight_layout(rect=[0, 0, 1, 0.96])&#10;            plt.show()&#10;&#10;        return y_out, chan_out&#10;&#10;&#10;&#10;    @staticmethod&#10;    def transmit(s: np.ndarray, h: np.ndarray, noise_var: float, num_res: int, cfo_and_iqmm_in_rx: bool, n_users: int, pilots_length: int) -&gt; np.ndarray:&#10;        &quot;&quot;&quot;&#10;        The MIMO SED Channel&#10;        :param s: to transmit symbol words&#10;        :param snr: signal-to-noise value&#10;        :param h: channel function&#10;        :return: received word&#10;        &quot;&quot;&quot;&#10;&#10;        empty_tf_tensor = tf.zeros([0], dtype=tf.float32)&#10;        y = np.zeros((conf.n_ants, s.shape[1], num_res), dtype=complex)&#10;        if not (conf.separate_pilots):&#10;            y_ce = np.zeros((n_users, conf.n_ants, s.shape[1], num_res), dtype=complex)&#10;        else:&#10;            y_ce = np.zeros_like(y, dtype=complex)&#10;&#10;        if conf.TDL_model[0] == 'N':&#10;&#10;            for re_index in range(num_res):&#10;                    conv = SEDChannel._compute_channel_signal_convolution(h[:,:,re_index], s[:,:,re_index])&#10;                    y[:, :, re_index] = conv&#10;&#10;                    if not(conf.separate_pilots):&#10;                        all_values = list(range(n_users))&#10;                        for user in range(n_users):&#10;                            idx = np.setdiff1d(all_values, user)&#10;                            s_cur_user = s[:, :, re_index].copy()&#10;                            s_cur_user[idx,:] = 0&#10;                            conv_ce = SEDChannel._compute_channel_signal_convolution(h[:,:,re_index], s_cur_user)&#10;                            y_ce[user, :, :, re_index] = conv_ce&#10;                    else:&#10;                        s_separate_pilots = np.zeros((s.shape[0],s.shape[1]), dtype=complex)&#10;                        for user in range(n_users):&#10;                            s_separate_pilots[user,user::n_users] = s[user,user::n_users,re_index]&#10;                        conv_ce = SEDChannel._compute_channel_signal_convolution(h[:, :, re_index], s_separate_pilots)&#10;                        y_ce[:, :, re_index] = conv_ce&#10;&#10;            if cfo_and_iqmm_in_rx and ((conf.cfo!=0) or (conf.iqmm_gain!=0) or (conf.iqmm_phase!=0)):&#10;                y , _ = SEDChannel.apply_td_and_impairments(y, True, 0, 100, num_res, n_users, False, empty_tf_tensor, 0, 0, conf.channel_seed, False)&#10;                y_ce , _ = SEDChannel.apply_td_and_impairments(y_ce, True, 0, 100, num_res, n_users, False, empty_tf_tensor, 0, 0, conf.channel_seed, False)&#10;&#10;        else:&#10;&#10;            pilot_chunk = int(pilots_length / np.log2(conf.mod_pilot))&#10;            if conf.pilot_channel_seed &lt; 0:&#10;                y, channel_used = SEDChannel.apply_td_and_impairments(s, True, 0, 100, num_res, n_users, True, empty_tf_tensor, 0, 0, conf.channel_seed, False)&#10;            else:&#10;                y_pilot, channel_used_pilot = SEDChannel.apply_td_and_impairments(s[:,:pilot_chunk,:], True, 0, 100, num_res, n_users, True, empty_tf_tensor, 0, 0, conf.pilot_channel_seed, False)&#10;                y_data, channel_used_data = SEDChannel.apply_td_and_impairments(s[:,pilot_chunk:,], True, 0, 100, num_res, n_users, True, empty_tf_tensor, 0, 0, conf.channel_seed, False)&#10;                y = np.concatenate((y_pilot, y_data), axis=1)&#10;&#10;            all_values = list(range(n_users))&#10;            if not(conf.separate_pilots):&#10;                for user in range(n_users):&#10;                    idx = np.setdiff1d(all_values, user)&#10;                    s_cur_user = s.copy()&#10;                    s_cur_user[idx, :, :] = 0&#10;                    conv_ce, _ = SEDChannel.apply_td_and_impairments(s_cur_user, True, 0, 100, num_res, 1, True, channel_used, 0, 0, conf.channel_seed, False)&#10;                    y_ce[user, :, :, :] = conv_ce&#10;            else:&#10;                s_separate_pilots = np.zeros_like(s, dtype=complex)&#10;                for user in range(n_users):&#10;                    s_separate_pilots[user, user::n_users,:] = s[user, user::n_users, :]&#10;&#10;                if conf.pilot_channel_seed &lt; 0:&#10;                    conv_ce, _ = SEDChannel.apply_td_and_impairments(s_separate_pilots, True, 0, 100, num_res, 1, True, channel_used, 0, 0, conf.channel_seed, False)&#10;                else:&#10;                    conv_ce_pilot, _ = SEDChannel.apply_td_and_impairments(s_separate_pilots[:,:pilot_chunk,:], True, 0, 100, num_res, 1, True, channel_used_pilot, 0, 0, conf.pilot_channel_seed, False)&#10;                    conv_ce_data, _ = SEDChannel.apply_td_and_impairments(s_separate_pilots[:,pilot_chunk:,:], True, 0, 100, num_res, 1, True, channel_used_data, 0, 0, conf.channel_seed, False)&#10;                    conv_ce = np.concatenate((conv_ce_pilot, conv_ce_data), axis=1)&#10;&#10;                y_ce[:, :, :] = conv_ce&#10;&#10;&#10;        if conf.iqmm_gain != 0 or conf.iqmm_phase != 0 or conf.cfo != 0:&#10;            y , _ = SEDChannel.apply_td_and_impairments(y, True, conf.cfo, 100, num_res, n_users, False, empty_tf_tensor, conf.iqmm_gain, conf.iqmm_phase, conf.channel_seed, False)&#10;            y_ce , _ = SEDChannel.apply_td_and_impairments(y_ce, True, conf.cfo, 100, num_res, n_users, False, empty_tf_tensor, conf.iqmm_gain, conf.iqmm_phase, conf.channel_seed, False)&#10;&#10;        for re_index in range(num_res):&#10;            w = np.sqrt(noise_var) * (np.random.randn(conf.n_ants, s.shape[1]) + 1j * np.random.randn(conf.n_ants, s.shape[1]))&#10;            y[:, :, re_index] = y[:, :, re_index] + w&#10;            if not conf.separate_pilots:&#10;                for user in range(n_users):&#10;                    y_ce[user,:, :, re_index] = y_ce[user,:, :, re_index] + w&#10;            else:&#10;                y_ce[:, :, re_index] = y_ce[:, :, re_index] + w&#10;&#10;        return y,y_ce&#10;&#10;    @staticmethod&#10;    def _compute_channel_signal_convolution(h: np.ndarray, s: np.ndarray) -&gt; np.ndarray:&#10;        conv = np.matmul(h, s)&#10;        return conv&#10;&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;from sympy import false&#10;&#10;from python_code import conf&#10;from python_code.utils.constants import (NUM_SYMB_PER_SLOT, FFT_size, FIRST_CP,CP, NUM_SAMPLES_PER_SLOT)&#10;&#10;import matplotlib.pyplot as plt&#10;import tensorflow as tf&#10;from typing import Tuple&#10;&#10;from python_code.analog.iqmm_model import apply_iq_mismatch&#10;&#10;&#10;&#10;H_COEF = 0.8&#10;&#10;from python_code.channel.sionna.TLD_channel import TDLChannel&#10;&#10;&#10;class SEDChannel:&#10;    @staticmethod&#10;    def calculate_channel(n_ant: int, n_users: int, num_res: int) -&gt; np.ndarray:&#10;        H_real = SEDChannel.mapping_matrix(n_users, n_ant)&#10;        H_complex = np.zeros((H_real.shape[0], H_real.shape[1], num_res), dtype=complex)&#10;        for re_index in range(num_res):&#10;            H_complex[:,:,re_index] = H_real&#10;        return H_complex&#10;&#10;&#10;    @staticmethod&#10;    def hadamard_matrix(n):&#10;        &quot;&quot;&quot;Generate Hadamard matrix of order n (must be power of 2).&quot;&quot;&quot;&#10;        if n == 1:&#10;            return np.array([[1]])&#10;        H = SEDChannel.hadamard_matrix(n // 2)&#10;        return np.block([[H, H], [H, -H]])&#10;&#10;    @staticmethod&#10;    def mapping_matrix(n_layers, n_rx):&#10;        &quot;&quot;&quot;Generate mapping matrix using Hadamard construction.&quot;&quot;&quot;&#10;        # Find nearest power of 2 &gt;= n_rx&#10;        N = 1&#10;        while N &lt; n_rx:&#10;            N *= 2&#10;        H = SEDChannel.hadamard_matrix(N)&#10;&#10;        # Normalize&#10;        H = H / np.sqrt(N)&#10;&#10;        # Take first n_rx rows and first n_layers columns&#10;        return H[:n_rx, :n_layers]&#10;&#10;&#10;    @staticmethod&#10;    def _add_fading(H: np.ndarray, n_ant: int, frame_ind: int) -&gt; np.ndarray:&#10;        degs_array = np.array([51, 39, 33, 21])&#10;        fade_mat = H_COEF + (1 - H_COEF) * np.cos(2 * np.pi * frame_ind / degs_array)&#10;        fade_mat = np.tile(fade_mat.reshape(1, -1), [n_ant, 1])&#10;        return H * fade_mat&#10;&#10;    @staticmethod&#10;    def apply_td_and_impairments(y_in, td_in_rx, cfo, clip_percentage_in_tx, num_res, n_users, tdl_channel: bool, external_chan: tf.Tensor, iqmm_gain, iqmm_phase, seed, run_tdcnn) -&gt; Tuple[np.ndarray, tf.Tensor]:&#10;&#10;        if td_in_rx:&#10;            if not(tdl_channel):&#10;                if y_in.ndim == 4:&#10;                    NUM_SLOTS = int(y_in.shape[2] / NUM_SYMB_PER_SLOT)&#10;                    NUM_SAMPLES_TOTAL = int(NUM_SLOTS * NUM_SAMPLES_PER_SLOT)&#10;                    n_users_int = n_users&#10;                    y = y_in&#10;                else:&#10;                    NUM_SLOTS = int(y_in.shape[1] / NUM_SYMB_PER_SLOT)&#10;                    NUM_SAMPLES_TOTAL = int(NUM_SLOTS * NUM_SAMPLES_PER_SLOT)&#10;                    n_users_int = 1&#10;                    y = np.expand_dims(y_in, axis=0)&#10;                n_input_rx_int = y.shape[1]&#10;                n_users_out_int = n_users_int&#10;            else:&#10;                NUM_SLOTS = int(y_in.shape[1] / NUM_SYMB_PER_SLOT)&#10;                NUM_SAMPLES_TOTAL = int(NUM_SLOTS * NUM_SAMPLES_PER_SLOT)&#10;                n_users_int = y_in.shape[0]&#10;                y = np.expand_dims(y_in, axis=1)&#10;                n_input_rx_int = 1&#10;                n_users_out_int = 1&#10;        else:&#10;            NUM_SLOTS = int(y_in.shape[1] / NUM_SYMB_PER_SLOT)&#10;            NUM_SAMPLES_TOTAL = int(NUM_SLOTS * NUM_SAMPLES_PER_SLOT)&#10;            n_users_int = n_users&#10;            n_input_rx_int = 1;&#10;            n_users_out_int = n_users&#10;            y = np.expand_dims(y_in, axis=1)&#10;&#10;        st_full = np.zeros((n_users_int, n_input_rx_int, NUM_SAMPLES_TOTAL), dtype=complex)&#10;&#10;        # OFDM modulation:&#10;        for user in range(n_users_int):&#10;            for rx in range(n_input_rx_int):&#10;                st_one_antenna = np.array([])&#10;                for slot_num in range(NUM_SLOTS):&#10;                    cp_length = FIRST_CP&#10;                    for ofdm_symbol in range(NUM_SYMB_PER_SLOT):&#10;                        cur_index = slot_num * NUM_SYMB_PER_SLOT + ofdm_symbol&#10;                        s_t = np.fft.ifft(y[user, rx, cur_index, :], n=FFT_size)&#10;                        s_t_with_cp = np.concatenate((s_t[-cp_length:], s_t))&#10;                        st_one_antenna = np.concatenate((st_one_antenna, s_t_with_cp))&#10;                        cp_length = CP&#10;                st_full[user,rx, :] = st_one_antenna&#10;&#10;        if (cfo != 0):&#10;            n = np.arange(NUM_SAMPLES_PER_SLOT)&#10;            cfo_phase = 2 * np.pi * cfo * n / FFT_size  # CFO phase shift&#10;            cfo_phase = np.tile(cfo_phase,NUM_SLOTS)&#10;            st_full = st_full * np.exp(1j * cfo_phase)&#10;&#10;        # Save a copy of the time-domain signal before clipping when TD-CNN input is requested&#10;        if run_tdcnn:&#10;            st_full_before = st_full.copy()&#10;        else:&#10;            st_full_before = None&#10;&#10;        if clip_percentage_in_tx&lt;100:&#10;            rms_value = np.mean(np.sqrt(np.mean(np.abs(st_full) ** 2, axis=2)))  # Compute RMS of the signal&#10;            clip_level_12dB = rms_value * (10 ** (12 / 20))  # 12 dB above RMS&#10;            clip_level = (clip_percentage_in_tx / 100) * clip_level_12dB  # Scale by percentage&#10;&#10;            magnitude = np.abs(st_full)  # Compute magnitude&#10;            phase = np.angle(st_full)  # Compute phase&#10;&#10;            # Apply clipping to magnitude&#10;            magnitude_clipped = np.minimum(magnitude, clip_level)&#10;&#10;            # Reconstruct clipped signal with original phase&#10;            st_full = magnitude_clipped * np.exp(1j * phase)&#10;            # new_rms_value = np.mean(np.sqrt(np.mean(np.abs(st_full) ** 2, axis=2)))  # Compute RMS of the signal&#10;            # st_full = st_full*rms_value/new_rms_value&#10;&#10;&#10;        # from scipy.io import savemat&#10;        # savemat('C:\\Projects\\Scratchpad\\temp_mat_files\\clip_debug.mat', {'st_full_before': st_full_before, 'st_full_after': st_full})&#10;&#10;&#10;        if iqmm_gain!=0 or iqmm_phase!=0:&#10;            st_full = apply_iq_mismatch(st_full, iqmm_gain, iqmm_phase)&#10;&#10;        if tdl_channel and td_in_rx:&#10;            st_out, chan_out = TDLChannel.conv_cir(st_full,1,0, NUM_SLOTS, external_chan, seed)&#10;            st_full = st_out&#10;        else:&#10;            chan_out = tf.zeros([0], dtype=tf.float32)&#10;&#10;        y_out_pre = np.zeros((n_users_out_int,st_full.shape[1],y.shape[2],y.shape[3]), dtype=np.complex64)&#10;        # --- Added for s_t_no_cp collection ---&#10;        # --- Allocate s_t_no_cp_matrix and s_t_no_cp_matrix_before with an explicit user dimension&#10;        # so the shape becomes (n_users_out_int, NUM_SLOTS, 2*n_rx, FFT_size, NUM_SYMB_PER_SLOT).&#10;        if run_tdcnn:&#10;            s_t_no_cp_matrix = np.zeros((n_users_out_int, NUM_SLOTS, 2 * st_full.shape[1], FFT_size, NUM_SYMB_PER_SLOT), dtype=np.float32)&#10;            # Keep a copy of the same structure for the pre-clipping samples&#10;            s_t_no_cp_matrix_before = np.zeros_like(s_t_no_cp_matrix)&#10;        else:&#10;            s_t_no_cp_matrix = None&#10;            s_t_no_cp_matrix_before = None&#10;        # --------------------------------------------------------------------------------------&#10;        for user in range(n_users_out_int):&#10;            for rx in range(st_full.shape[1]):&#10;                pointer = 0&#10;                index = 0&#10;                for slot_num in range(NUM_SLOTS):&#10;                    cp_length = FIRST_CP&#10;                    for ofdm_symbol in range(NUM_SYMB_PER_SLOT):&#10;                        s_t_no_cp = st_full[user, rx, pointer + cp_length:pointer + cp_length + FFT_size]&#10;                        S_no_cp = np.fft.fft(s_t_no_cp, n=FFT_size)&#10;                        y_out_pre[user, rx, index, :] = S_no_cp[:num_res]&#10;                        # --- Store real and imag in the matrix ---&#10;                        if run_tdcnn:&#10;                            # post-clipping samples: store under the [user, slot_num, ...] index&#10;                            s_t_no_cp_matrix[user, slot_num, 2*rx, :, ofdm_symbol] = np.real(s_t_no_cp)&#10;                            s_t_no_cp_matrix[user, slot_num, 2*rx+1, :, ofdm_symbol] = np.imag(s_t_no_cp)&#10;&#10;                            # pre-clipping samples (if available)&#10;                            if st_full_before is not None:&#10;                                s_t_no_cp_before = st_full_before[user, rx, pointer + cp_length:pointer + cp_length + FFT_size]&#10;                                s_t_no_cp_matrix_before[user, slot_num, 2*rx, :, ofdm_symbol] = np.real(s_t_no_cp_before)&#10;                                s_t_no_cp_matrix_before[user, slot_num, 2*rx+1, :, ofdm_symbol] = np.imag(s_t_no_cp_before)&#10;                        # ----------------------------------------&#10;                        pointer += (cp_length + FFT_size)&#10;                        cp_length = CP&#10;                        index += 1&#10;        # s_t_no_cp_matrix is now organized as (n_users_out_int, NUM_SLOTS, 2*n_rx, FFT_size, NUM_SYMB_PER_SLOT)&#10;        # where the first axis indexes the user and the second axis indexes the slot.&#10;&#10;        # --- TD-CNN training &amp; inference (per-user instances) ---&#10;        if run_tdcnn and (s_t_no_cp_matrix is not None) and (s_t_no_cp_matrix_before is not None):&#10;            try:&#10;                # Output container: same shape as s_t_no_cp_matrix&#10;                s_t_no_cp_matrix_tdcnn_out = np.zeros_like(s_t_no_cp_matrix)&#10;                # Store models and outputs on the class for later inspection/calling&#10;                SEDChannel.last_tdcnn_models = []&#10;                SEDChannel.last_s_t_no_cp_matrix_tdcnn_output = None&#10;&#10;                # Train on 1/5 of the slots (at least 1)&#10;                train_count = max(1, int(NUM_SLOTS // 5))&#10;                epochs = 5&#10;&#10;                for user_idx in range(n_users_out_int):&#10;                    # Per-user data: shape (NUM_SLOTS, channels, FFT_size, NUM_SYMB_PER_SLOT)&#10;                    X = s_t_no_cp_matrix[user_idx]&#10;                    Y = s_t_no_cp_matrix_before[user_idx]&#10;                    # Move channel axis to last for TF: (NUM_SLOTS, FFT_size, NUM_SYMB_PER_SLOT, channels)&#10;                    X_t = np.transpose(X, (0, 2, 3, 1))&#10;                    Y_t = np.transpose(Y, (0, 2, 3, 1))&#10;&#10;                    if X_t.shape[0] &lt; 1:&#10;                        # nothing to train/infer&#10;                        SEDChannel.last_tdcnn_models.append(None)&#10;                        continue&#10;&#10;                    input_shape = X_t.shape[1:]&#10;&#10;                    # Build a small encoder-decoder-like CNN that maps corrupted-&gt;clean per-slot&#10;                    tf.keras.backend.clear_session()&#10;                    model = tf.keras.Sequential([&#10;                        tf.keras.layers.Input(shape=input_shape),&#10;                        tf.keras.layers.Conv2D(32, (3, 3), padding='same', activation='relu'),&#10;                        tf.keras.layers.Conv2D(32, (3, 3), padding='same', activation='relu'),&#10;                        tf.keras.layers.Conv2D(input_shape[2], (3, 3), padding='same', activation=None)&#10;                    ])&#10;                    model.compile(optimizer='adam', loss='mse')&#10;&#10;                    # Prepare small training subset&#10;                    X_train = X_t[:train_count]&#10;                    Y_train = Y_t[:train_count]&#10;&#10;                    if X_train.shape[0] &gt; 0:&#10;                        model.fit(X_train, Y_train, epochs=epochs, batch_size=max(1, min(8, X_train.shape[0])), verbose=0)&#10;&#10;                    # Inference on all slots (including training samples)&#10;                    Y_pred = model.predict(X_t, verbose=0)&#10;                    # transpose back to original internal layout (NUM_SLOTS, channels, FFT_size, NUM_SYMB_PER_SLOT)&#10;                    Y_pred_t = np.transpose(Y_pred, (0, 3, 1, 2)).astype(np.float32)&#10;                    s_t_no_cp_matrix_tdcnn_out[user_idx] = Y_pred_t&#10;&#10;                    SEDChannel.last_tdcnn_models.append(model)&#10;&#10;                # Save final outputs for later use&#10;                SEDChannel.last_s_t_no_cp_matrix_tdcnn_output = s_t_no_cp_matrix_tdcnn_out&#10;            except Exception as e:&#10;                # On any failure keep attributes for debugging&#10;                SEDChannel.last_tdcnn_models = getattr(SEDChannel, 'last_tdcnn_models', [])&#10;                SEDChannel.last_s_t_no_cp_matrix_tdcnn_output = None&#10;&#10;        if td_in_rx:&#10;            if y_in.ndim == 4: # Multiple users&#10;                y_out = y_out_pre&#10;            else:&#10;                y_out = np.squeeze(y_out_pre, axis=0)&#10;        else:&#10;            y_out = np.squeeze(y_out_pre, axis=1)&#10;&#10;&#10;&#10;        # -----------------------------------------------------------------------------------------------&#10;        show_impair_tx = False&#10;        if show_impair_tx:&#10;            fig, axs = plt.subplots(4, 1, figsize=(8, 10))&#10;&#10;            # --- Real part ---&#10;            axs[0].stem(np.real(y_in[0, 0, :]), linefmt='b-', markerfmt='bo', basefmt=&quot; &quot;, label='Before')&#10;            axs[0].stem(np.real(y_out[0, 0, :]), linefmt='r--', markerfmt='ro', basefmt=&quot; &quot;, label='After')&#10;            axs[0].set_ylabel('I')&#10;            axs[0].grid(True)&#10;            axs[0].legend()&#10;&#10;            # --- Imag part ---&#10;            axs[1].stem(np.imag(y_in[0, 0, :]), linefmt='b-', markerfmt='bo', basefmt=&quot; &quot;, label='Before')&#10;            axs[1].stem(np.imag(y_out[0, 0, :]), linefmt='r--', markerfmt='ro', basefmt=&quot; &quot;, label='After')&#10;            axs[1].set_ylabel('Q')&#10;            axs[1].grid(True)&#10;            axs[1].legend()&#10;&#10;            # --- Abs ---&#10;            axs[2].stem(np.abs(y_in[0, 0, :]), linefmt='b-', markerfmt='bo', basefmt=&quot; &quot;, label='Before')&#10;            axs[2].stem(np.abs(y_out[0, 0, :]), linefmt='r--', markerfmt='ro', basefmt=&quot; &quot;, label='After')&#10;            axs[2].set_ylabel('Abs')&#10;            axs[2].grid(True)&#10;            axs[2].legend()&#10;&#10;            # --- Constellation diagram ---&#10;            axs[3].scatter(np.real(y_out.flatten()), np.imag(y_out.flatten()), color='r', alpha=0.5,&#10;                           label='After')&#10;            axs[3].scatter(np.real(y_in.flatten()), np.imag(y_in.flatten()), color='b', alpha=0.5,&#10;                           label='Before')&#10;            axs[3].set_xlabel('I')&#10;            axs[3].set_ylabel('Q')&#10;            axs[3].grid(True)&#10;            axs[3].axis('equal')&#10;            axs[3].legend()&#10;&#10;            # --- Global title ---&#10;            # fig.suptitle('Impairment effect with clipping = ' + str(clip_percentage_in_tx) + '%', fontsize=14)&#10;            fig.suptitle('Impairment effect with IQMM gain = ' + str(conf.iqmm_gain) + 'dB, phase=' + str(conf.iqmm_phase) + '°', fontsize=14)&#10;&#10;            plt.tight_layout(rect=[0, 0, 1, 0.96])&#10;            plt.show()&#10;&#10;        return y_out, chan_out&#10;&#10;&#10;&#10;    @staticmethod&#10;    def transmit(s: np.ndarray, h: np.ndarray, noise_var: float, num_res: int, cfo_and_iqmm_in_rx: bool, n_users: int, pilots_length: int) -&gt; np.ndarray:&#10;        &quot;&quot;&quot;&#10;        The MIMO SED Channel&#10;        :param s: to transmit symbol words&#10;        :param snr: signal-to-noise value&#10;        :param h: channel function&#10;        :return: received word&#10;        &quot;&quot;&quot;&#10;&#10;        empty_tf_tensor = tf.zeros([0], dtype=tf.float32)&#10;        y = np.zeros((conf.n_ants, s.shape[1], num_res), dtype=complex)&#10;        if not (conf.separate_pilots):&#10;            y_ce = np.zeros((n_users, conf.n_ants, s.shape[1], num_res), dtype=complex)&#10;        else:&#10;            y_ce = np.zeros_like(y, dtype=complex)&#10;&#10;        if conf.TDL_model[0] == 'N':&#10;&#10;            for re_index in range(num_res):&#10;                    conv = SEDChannel._compute_channel_signal_convolution(h[:,:,re_index], s[:,:,re_index])&#10;                    y[:, :, re_index] = conv&#10;&#10;                    if not(conf.separate_pilots):&#10;                        all_values = list(range(n_users))&#10;                        for user in range(n_users):&#10;                            idx = np.setdiff1d(all_values, user)&#10;                            s_cur_user = s[:, :, re_index].copy()&#10;                            s_cur_user[idx,:] = 0&#10;                            conv_ce = SEDChannel._compute_channel_signal_convolution(h[:,:,re_index], s_cur_user)&#10;                            y_ce[user, :, :, re_index] = conv_ce&#10;                    else:&#10;                        s_separate_pilots = np.zeros((s.shape[0],s.shape[1]), dtype=complex)&#10;                        for user in range(n_users):&#10;                            s_separate_pilots[user,user::n_users] = s[user,user::n_users,re_index]&#10;                        conv_ce = SEDChannel._compute_channel_signal_convolution(h[:, :, re_index], s_separate_pilots)&#10;                        y_ce[:, :, re_index] = conv_ce&#10;&#10;            if cfo_and_iqmm_in_rx and ((conf.cfo!=0) or (conf.iqmm_gain!=0) or (conf.iqmm_phase!=0)):&#10;                y , _ = SEDChannel.apply_td_and_impairments(y, True, 0, 100, num_res, n_users, False, empty_tf_tensor, 0, 0, conf.channel_seed, False)&#10;                y_ce , _ = SEDChannel.apply_td_and_impairments(y_ce, True, 0, 100, num_res, n_users, False, empty_tf_tensor, 0, 0, conf.channel_seed, False)&#10;&#10;        else:&#10;&#10;            pilot_chunk = int(pilots_length / np.log2(conf.mod_pilot))&#10;            if conf.pilot_channel_seed &lt; 0:&#10;                y, channel_used = SEDChannel.apply_td_and_impairments(s, True, 0, 100, num_res, n_users, True, empty_tf_tensor, 0, 0, conf.channel_seed, False)&#10;            else:&#10;                y_pilot, channel_used_pilot = SEDChannel.apply_td_and_impairments(s[:,:pilot_chunk,:], True, 0, 100, num_res, n_users, True, empty_tf_tensor, 0, 0, conf.pilot_channel_seed, False)&#10;                y_data, channel_used_data = SEDChannel.apply_td_and_impairments(s[:,pilot_chunk:,], True, 0, 100, num_res, n_users, True, empty_tf_tensor, 0, 0, conf.channel_seed, False)&#10;                y = np.concatenate((y_pilot, y_data), axis=1)&#10;&#10;            all_values = list(range(n_users))&#10;            if not(conf.separate_pilots):&#10;                for user in range(n_users):&#10;                    idx = np.setdiff1d(all_values, user)&#10;                    s_cur_user = s.copy()&#10;                    s_cur_user[idx, :, :] = 0&#10;                    conv_ce, _ = SEDChannel.apply_td_and_impairments(s_cur_user, True, 0, 100, num_res, 1, True, channel_used, 0, 0, conf.channel_seed, False)&#10;                    y_ce[user, :, :, :] = conv_ce&#10;            else:&#10;                s_separate_pilots = np.zeros_like(s, dtype=complex)&#10;                for user in range(n_users):&#10;                    s_separate_pilots[user, user::n_users,:] = s[user, user::n_users, :]&#10;&#10;                if conf.pilot_channel_seed &lt; 0:&#10;                    conv_ce, _ = SEDChannel.apply_td_and_impairments(s_separate_pilots, True, 0, 100, num_res, 1, True, channel_used, 0, 0, conf.channel_seed, False)&#10;                else:&#10;                    conv_ce_pilot, _ = SEDChannel.apply_td_and_impairments(s_separate_pilots[:,:pilot_chunk,:], True, 0, 100, num_res, 1, True, channel_used_pilot, 0, 0, conf.pilot_channel_seed, False)&#10;                    conv_ce_data, _ = SEDChannel.apply_td_and_impairments(s_separate_pilots[:,pilot_chunk:,:], True, 0, 100, num_res, 1, True, channel_used_data, 0, 0, conf.channel_seed, False)&#10;                    conv_ce = np.concatenate((conv_ce_pilot, conv_ce_data), axis=1)&#10;&#10;                y_ce[:, :, :] = conv_ce&#10;&#10;&#10;        if conf.iqmm_gain != 0 or conf.iqmm_phase != 0 or conf.cfo != 0:&#10;            y , _ = SEDChannel.apply_td_and_impairments(y, True, conf.cfo, 100, num_res, n_users, False, empty_tf_tensor, conf.iqmm_gain, conf.iqmm_phase, conf.channel_seed, False)&#10;            y_ce , _ = SEDChannel.apply_td_and_impairments(y_ce, True, conf.cfo, 100, num_res, n_users, False, empty_tf_tensor, conf.iqmm_gain, conf.iqmm_phase, conf.channel_seed, False)&#10;&#10;        for re_index in range(num_res):&#10;            w = np.sqrt(noise_var) * (np.random.randn(conf.n_ants, s.shape[1]) + 1j * np.random.randn(conf.n_ants, s.shape[1]))&#10;            y[:, :, re_index] = y[:, :, re_index] + w&#10;            if not conf.separate_pilots:&#10;                for user in range(n_users):&#10;                    y_ce[user,:, :, re_index] = y_ce[user,:, :, re_index] + w&#10;            else:&#10;                y_ce[:, :, re_index] = y_ce[:, :, re_index] + w&#10;&#10;        return y,y_ce&#10;&#10;    @staticmethod&#10;    def _compute_channel_signal_convolution(h: np.ndarray, s: np.ndarray) -&gt; np.ndarray:&#10;        conv = np.matmul(h, s)&#10;        return conv&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>